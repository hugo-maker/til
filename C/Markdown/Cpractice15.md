# 15章 ポインタ変数の仕組み

## 配列の仕組み

- 配列名は配列の最初の要素のアドレスを表している
- array[i] は 配列名のアドレス(=配列の最初の要素のアドレス) + 要素番号 のメモリを参照しろ、ということ
- 要素番号1につき、アドレスは4ずつ増える(int 型のサイズは4のため)
- 最初のアドレスを決めると、それに番号を足していくことで、たくさんの変数が並んでいる状態を表せる

## &付けが必要な変数の正体

- &の正体は変数のアドレスを求める演算子
- 値渡し 関数に単なる数値として情報を渡す方法
  (変数を実引数に指定しても、渡されるのは変数そのものではなく、変数の数値のコピーに過ぎない。つまり、呼び出し側の変数を書き換えることができない。)
- C言語では上記の値渡ししかできないが、アドレスを渡すことで参照渡しの機能を再現(?)できる
- 参照渡し アドレスを渡す処理を言語の機能で自動的に行うこと

## scanf関数で&をつける理由

- C言語では値渡ししかできないため、&を付けないと変数に新たな値を記憶することができないから
- 文字列入力の際に配列名の前に&を付けない理由→ 配列名は配列の最初の要素のアドレスを表しているため、配列名さえ渡せば配列のアドレスがわかるから
  (実際には&付きの変数を指定しているのとまったく同じ)

## アドレスを記憶する変数:ポインタとは

### ポインタとは

- ポインタとは、アドレスを扱う3つの機能の総称

### 3つの機能

- ポインタ型 int型やdouble型と同様なデータ型。ただし、ポインタ型独自の特徴あり
- ポインタ値 ポインタ型で扱える数値(=アドレス)のこと
- ポインタ変数 ポインタ型で宣言された、ポインタ値を記憶できる変数のこと。int型やdouble型の変数と基本的にはいっしょ

### ポインタ型

- ポインタ型は、他の型(int型など)から作り出される派生型=独立には存在できない
- 他の型と合体させて作る ← 指定アドレスに記憶された数値を取り出すため
  (型によってサイズが異なっているし、場合によっては2進数の読み方まで異なる(浮動少数点とか?)ため、
  どんな型の変数のアドレスだったかわからなければ、数値の取り出しようがない)
- 実は、独立に存在できるvoid型というのもある

### ポインタ値

- ポインタ値 = 変数のアドレスの値
- ポインタ値を使う理由 通常の整数値とポインタ値では扱う目的がまったく異なるため、別々に管理したほうがわかりやすいから

### ポインタ変数

- ポインタ変数 = ポインタ型で宣言された実際の変数
- 元となった型の変数のアドレスを自由に代入できる
- 記憶しているアドレスのメモリの読みとりと書き換えができる
- ポインタ変数の目的は、記憶しているアドレスのメモリ操作
- ポインタ変数モードと通常変数モードを必要に応じて切り替えて使用(メモリ操作が必要なときは通常の変数に変身する)

## ポインタ変数の使用

- 変数名の前に\*をつける 例: int \*p
- ポインタ変数モード時に読み書きしたいメモリのアドレスを代入して、その後、通常変数モードに転換してそのメモリを操作する
  (Vimのノーマルモードと挿入モードにほんのちょっと似てる......のか？)
- 「乗算演算子\*」と 「間接参照演算子\*」 と 「ポインタ変数の宣言時に用いる\*」はそれぞれ**全くの別物**
- ポインタとは 要はデスクトップのショートカットみたいなもんである
- ショートカット機能としてのポインタは、連結リストやオブジェクト指向の実現に必要
  → 仮にポインタの概念がない言語でも、アドレスを直接代入できない形で(つまり、抽象化してわかりやすくした形で)ポインタ同様のショートカット機能は導入されている

## 引数による情報の受け渡し

### ポインタ型の引数

- 関数からポインタ型の引数を使って情報を返すことができる

### 配列型の引数

- 要素数が無視される
- 実は、配列の先頭のアドレスを渡している
- おすすめの書きかた例 関数の仮引数宣言時 int getaverage(int data[]) 要素数は無視されるので書かず、配列を受け取ることを明示する
  int getaverage(int data[10]) ← 幼稚 int getaverage(int *data) ← 普通のポインタ型と混同する恐れがある

## 配列とポインタの奇妙な関係

### ポインタの配列のような使い方

- 配列宣言時の[] と、要素数を指定して配列の要素を使うときの[] は**実は別物**
- 宣言時の[] は要素数を指定するという意味
- 数式の中で使用する[] は、アドレスに足し算する演算子
- 以上から、ポインタ変数は配列のように使えてしまう(動的メモリ確保をする際に用いるテクニック)

### ポインタ演算

- *(ポインタ変数 + 要素番号)
- わかりにくいのでこの書き方はしないように(ただし組み込みでは、この書き方のほうがコンパイラにやさしい)
